{"version":3,"sources":["webpack:///./node_modules/jwa/index.js"],"names":["bufferEqual","Buffer","crypto","formatEcdsa","util","MSG_INVALID_ALGORITHM","MSG_INVALID_SECRET","MSG_INVALID_VERIFIER_KEY","MSG_INVALID_SIGNER_KEY","supportsKeyObjects","createPublicKey","checkIsPublicKey","key","isBuffer","typeError","type","asymmetricKeyType","export","checkIsPrivateKey","checkIsSecretKey","fromBase64","base64","replace","toBase64","base64url","toString","padding","length","i","template","args","slice","call","arguments","errMsg","format","bind","apply","TypeError","bufferOrString","obj","normalizeInput","thing","JSON","stringify","createHmacSigner","bits","secret","hmac","createHmac","sig","update","digest","createHmacVerifier","signature","computedSig","from","createKeySigner","privateKey","signer","createSign","sign","createKeyVerifier","publicKey","verifier","createVerify","verify","createPSSKeySigner","constants","RSA_PKCS1_PSS_PADDING","saltLength","RSA_PSS_SALTLEN_DIGEST","createPSSKeyVerifier","createECDSASigner","inner","derToJose","createECDSAVerifer","joseToDer","result","createNoneSigner","createNoneVerifier","module","exports","algorithm","signerFactories","hs","rs","ps","es","none","verifierFactories","match","algo","toLowerCase"],"mappings":"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","file":"js/npm.jwa-legacy.b7680db1.js","sourcesContent":["var bufferEqual = require('buffer-equal-constant-time');\nvar Buffer = require('safe-buffer').Buffer;\nvar crypto = require('crypto');\nvar formatEcdsa = require('ecdsa-sig-formatter');\nvar util = require('util');\n\nvar MSG_INVALID_ALGORITHM = '\"%s\" is not a valid algorithm.\\n  Supported algorithms are:\\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".'\nvar MSG_INVALID_SECRET = 'secret must be a string or buffer';\nvar MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';\nvar MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';\n\nvar supportsKeyObjects = typeof crypto.createPublicKey === 'function';\nif (supportsKeyObjects) {\n  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';\n  MSG_INVALID_SECRET += 'or a KeyObject';\n}\n\nfunction checkIsPublicKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.type !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.asymmetricKeyType !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n};\n\nfunction checkIsPrivateKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (typeof key === 'object') {\n    return;\n  }\n\n  throw typeError(MSG_INVALID_SIGNER_KEY);\n};\n\nfunction checkIsSecretKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (key.type !== 'secret') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n}\n\nfunction fromBase64(base64) {\n  return base64\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n\nfunction toBase64(base64url) {\n  base64url = base64url.toString();\n\n  var padding = 4 - base64url.length % 4;\n  if (padding !== 4) {\n    for (var i = 0; i < padding; ++i) {\n      base64url += '=';\n    }\n  }\n\n  return base64url\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n}\n\nfunction typeError(template) {\n  var args = [].slice.call(arguments, 1);\n  var errMsg = util.format.bind(util, template).apply(null, args);\n  return new TypeError(errMsg);\n}\n\nfunction bufferOrString(obj) {\n  return Buffer.isBuffer(obj) || typeof obj === 'string';\n}\n\nfunction normalizeInput(thing) {\n  if (!bufferOrString(thing))\n    thing = JSON.stringify(thing);\n  return thing;\n}\n\nfunction createHmacSigner(bits) {\n  return function sign(thing, secret) {\n    checkIsSecretKey(secret);\n    thing = normalizeInput(thing);\n    var hmac = crypto.createHmac('sha' + bits, secret);\n    var sig = (hmac.update(thing), hmac.digest('base64'))\n    return fromBase64(sig);\n  }\n}\n\nfunction createHmacVerifier(bits) {\n  return function verify(thing, signature, secret) {\n    var computedSig = createHmacSigner(bits)(thing, secret);\n    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));\n  }\n}\n\nfunction createKeySigner(bits) {\n return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    // Even though we are specifying \"RSA\" here, this works with ECDSA\n    // keys as well.\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));\n    return fromBase64(sig);\n  }\n}\n\nfunction createKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify(publicKey, signature, 'base64');\n  }\n}\n\nfunction createPSSKeySigner(bits) {\n  return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign({\n      key: privateKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, 'base64'));\n    return fromBase64(sig);\n  }\n}\n\nfunction createPSSKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify({\n      key: publicKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, signature, 'base64');\n  }\n}\n\nfunction createECDSASigner(bits) {\n  var inner = createKeySigner(bits);\n  return function sign() {\n    var signature = inner.apply(null, arguments);\n    signature = formatEcdsa.derToJose(signature, 'ES' + bits);\n    return signature;\n  };\n}\n\nfunction createECDSAVerifer(bits) {\n  var inner = createKeyVerifier(bits);\n  return function verify(thing, signature, publicKey) {\n    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');\n    var result = inner(thing, signature, publicKey);\n    return result;\n  };\n}\n\nfunction createNoneSigner() {\n  return function sign() {\n    return '';\n  }\n}\n\nfunction createNoneVerifier() {\n  return function verify(thing, signature) {\n    return signature === '';\n  }\n}\n\nmodule.exports = function jwa(algorithm) {\n  var signerFactories = {\n    hs: createHmacSigner,\n    rs: createKeySigner,\n    ps: createPSSKeySigner,\n    es: createECDSASigner,\n    none: createNoneSigner,\n  }\n  var verifierFactories = {\n    hs: createHmacVerifier,\n    rs: createKeyVerifier,\n    ps: createPSSKeyVerifier,\n    es: createECDSAVerifer,\n    none: createNoneVerifier,\n  }\n  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);\n  if (!match)\n    throw typeError(MSG_INVALID_ALGORITHM, algorithm);\n  var algo = (match[1] || match[3]).toLowerCase();\n  var bits = match[2];\n\n  return {\n    sign: signerFactories[algo](bits),\n    verify: verifierFactories[algo](bits),\n  }\n};\n"],"sourceRoot":""}