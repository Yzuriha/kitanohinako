{"version":3,"sources":["webpack:///./node_modules/https-proxy-agent/dist/agent.js","webpack:///./node_modules/https-proxy-agent/dist/index.js","webpack:///./node_modules/https-proxy-agent/dist/parse-proxy-response.js"],"names":["__awaiter","this","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","net_1","tls_1","url_1","assert_1","debug_1","agent_base_1","parse_proxy_response_1","debug","default","HttpsProxyAgent","Agent","_opts","opts","parse","Error","super","proxy","assign","secureProxy","isHTTPS","protocol","host","hostname","port","parseInt","ALPNProtocols","path","pathname","req","socket","connect","headers","payload","auth","Buffer","from","toString","secureEndpoint","isDefaultPort","Host","Connection","name","keys","proxyResponsePromise","write","statusCode","buffered","once","resume","servername","omit","destroy","fakeSocket","Socket","readable","s","listenerCount","push","secure","Boolean","test","obj","ret","key","includes","agent_1","createHttpsProxyAgent","prototype","module","parseProxyResponse","buffersLength","buffers","read","b","ondata","cleanup","removeListener","onend","onerror","onclose","err","length","concat","endOfHeaders","indexOf","firstLine","split","on"],"mappings":"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","file":"js/npm.https-proxy-agent-legacy.cac457ed.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = __importDefault(require(\"net\"));\nconst tls_1 = __importDefault(require(\"tls\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst agent_base_1 = require(\"agent-base\");\nconst parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('creating new HttpsProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n            proxy.ALPNProtocols = ['http 1.1'];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = 'close';\n            for (const name of Object.keys(headers)) {\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once('socket', resume);\n                if (opts.secureEndpoint) {\n                    const servername = opts.servername || opts.host;\n                    if (!servername) {\n                        throw new Error('Could not determine \"servername\"');\n                    }\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug('Upgrading socket connection to TLS');\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                        servername }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket();\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once('socket', (s) => {\n                debug('replaying proxy buffer for failed request');\n                assert_1.default(s.listenerCount('data') > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports.default = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean((!secure && port === 80) || (secure && port === 443));\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=agent.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst agent_1 = __importDefault(require(\"./agent\"));\nfunction createHttpsProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function (createHttpsProxyAgent) {\n    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;\n    createHttpsProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));\nmodule.exports = createHttpsProxyAgent;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            debug('onclose had error %o', err);\n        }\n        function onend() {\n            debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n            const statusCode = +firstLine.split(' ')[1];\n            debug('got proxy server response: %o', firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports.default = parseProxyResponse;\n//# sourceMappingURL=parse-proxy-response.js.map"],"sourceRoot":""}