{"version":3,"sources":["webpack:///./node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js","webpack:///./node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"],"names":["getParamSize","keySize","result","paramBytesForAlg","ES256","ES384","ES512","getParamBytesForAlg","alg","paramBytes","Error","module","exports","Buffer","MAX_OCTET","CLASS_UNIVERSAL","PRIMITIVE_BIT","TAG_SEQ","TAG_INT","ENCODED_TAG_SEQ","ENCODED_TAG_INT","base64Url","base64","replace","signatureAsBuffer","signature","isBuffer","from","TypeError","derToJose","maxEncodedParamLength","inputLength","length","offset","seqLength","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","toString","countPadding","buf","start","stop","padding","needsSign","joseToDer","signatureBytes","rsBytes","shortLength"],"mappings":"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","file":"js/npm.ecdsa-sig-formatter-legacy.c9a6b83a.js","sourcesContent":["'use strict';\n\nfunction getParamSize(keySize) {\n\tvar result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);\n\treturn result;\n}\n\nvar paramBytesForAlg = {\n\tES256: getParamSize(256),\n\tES384: getParamSize(384),\n\tES512: getParamSize(521)\n};\n\nfunction getParamBytesForAlg(alg) {\n\tvar paramBytes = paramBytesForAlg[alg];\n\tif (paramBytes) {\n\t\treturn paramBytes;\n\t}\n\n\tthrow new Error('Unknown algorithm \"' + alg + '\"');\n}\n\nmodule.exports = getParamBytesForAlg;\n","'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\n\nvar MAX_OCTET = 0x80,\n\tCLASS_UNIVERSAL = 0,\n\tPRIMITIVE_BIT = 0x20,\n\tTAG_SEQ = 0x10,\n\tTAG_INT = 0x02,\n\tENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),\n\tENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\n\nfunction base64Url(base64) {\n\treturn base64\n\t\t.replace(/=/g, '')\n\t\t.replace(/\\+/g, '-')\n\t\t.replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n\tif (Buffer.isBuffer(signature)) {\n\t\treturn signature;\n\t} else if ('string' === typeof signature) {\n\t\treturn Buffer.from(signature, 'base64');\n\t}\n\n\tthrow new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\t// the DER encoded param should at most be the param size, plus a padding\n\t// zero, since due to being a signed integer\n\tvar maxEncodedParamLength = paramBytes + 1;\n\n\tvar inputLength = signature.length;\n\n\tvar offset = 0;\n\tif (signature[offset++] !== ENCODED_TAG_SEQ) {\n\t\tthrow new Error('Could not find expected \"seq\"');\n\t}\n\n\tvar seqLength = signature[offset++];\n\tif (seqLength === (MAX_OCTET | 1)) {\n\t\tseqLength = signature[offset++];\n\t}\n\n\tif (inputLength - offset < seqLength) {\n\t\tthrow new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n\t}\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"r\"');\n\t}\n\n\tvar rLength = signature[offset++];\n\n\tif (inputLength - offset - 2 < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n\t}\n\n\tif (maxEncodedParamLength < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar rOffset = offset;\n\toffset += rLength;\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"s\"');\n\t}\n\n\tvar sLength = signature[offset++];\n\n\tif (inputLength - offset !== sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n\t}\n\n\tif (maxEncodedParamLength < sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar sOffset = offset;\n\toffset += sLength;\n\n\tif (offset !== inputLength) {\n\t\tthrow new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n\t}\n\n\tvar rPadding = paramBytes - rLength,\n\t\tsPadding = paramBytes - sLength;\n\n\tvar dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n\tfor (offset = 0; offset < rPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n\n\toffset = paramBytes;\n\n\tfor (var o = offset; offset < o + sPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n\n\tdst = dst.toString('base64');\n\tdst = base64Url(dst);\n\n\treturn dst;\n}\n\nfunction countPadding(buf, start, stop) {\n\tvar padding = 0;\n\twhile (start + padding < stop && buf[start + padding] === 0) {\n\t\t++padding;\n\t}\n\n\tvar needsSign = buf[start + padding] >= MAX_OCTET;\n\tif (needsSign) {\n\t\t--padding;\n\t}\n\n\treturn padding;\n}\n\nfunction joseToDer(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\tvar signatureBytes = signature.length;\n\tif (signatureBytes !== paramBytes * 2) {\n\t\tthrow new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n\t}\n\n\tvar rPadding = countPadding(signature, 0, paramBytes);\n\tvar sPadding = countPadding(signature, paramBytes, signature.length);\n\tvar rLength = paramBytes - rPadding;\n\tvar sLength = paramBytes - sPadding;\n\n\tvar rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n\n\tvar shortLength = rsBytes < MAX_OCTET;\n\n\tvar dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n\n\tvar offset = 0;\n\tdst[offset++] = ENCODED_TAG_SEQ;\n\tif (shortLength) {\n\t\t// Bit 8 has value \"0\"\n\t\t// bits 7-1 give the length.\n\t\tdst[offset++] = rsBytes;\n\t} else {\n\t\t// Bit 8 of first octet has value \"1\"\n\t\t// bits 7-1 give the number of additional length octets.\n\t\tdst[offset++] = MAX_OCTET\t| 1;\n\t\t// length, base 256\n\t\tdst[offset++] = rsBytes & 0xff;\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = rLength;\n\tif (rPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\toffset += signature.copy(dst, offset, 0, paramBytes);\n\t} else {\n\t\toffset += signature.copy(dst, offset, rPadding, paramBytes);\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = sLength;\n\tif (sPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\tsignature.copy(dst, offset, paramBytes);\n\t} else {\n\t\tsignature.copy(dst, offset, paramBytes + sPadding);\n\t}\n\n\treturn dst;\n}\n\nmodule.exports = {\n\tderToJose: derToJose,\n\tjoseToDer: joseToDer\n};\n"],"sourceRoot":""}