{"version":3,"sources":["webpack:///./node_modules/gtoken/build/src/index.js"],"names":["Object","defineProperty","exports","value","GoogleToken","fs","gaxios_1","jws","path","util_1","readFile","promisify","async","ErrorWithCode","GOOGLE_TOKEN_URL","GOOGLE_REVOKE_TOKEN_URL","Error","message","code","super","this","getPem","options","configure","rawToken","access_token","undefined","id_token","token_type","refresh_token","now","Date","getTime","expiresAt","_a","eagerRefreshThresholdMillis","callback","opts","assign","forceRefresh","getTokenAsync","cb","then","t","keyFile","ext","extname","key","body","JSON","parse","privateKey","private_key","clientEmail","client_email","Promise","resolve","inFlightRequest","getTokenAsyncInner","isTokenExpiring","creds","getCredentials","iss","ensureEmail","requestToken","revokeTokenAsync","accessToken","url","request","email","sub","scope","additionalClaims","join","iat","Math","floor","payload","aud","exp","signedJWT","sign","header","alg","secret","r","method","data","grant_type","assertion","headers","responseType","expires_in","e","tokenExpires","response","error","desc","error_description"],"mappings":"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","file":"js/npm.gtoken-legacy.4a46eb3a.js","sourcesContent":["\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GoogleToken = void 0;\nconst fs = require(\"fs\");\nconst gaxios_1 = require(\"gaxios\");\nconst jws = require(\"jws\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst readFile = fs.readFile\n    ? util_1.promisify(fs.readFile)\n    : async () => {\n        // if running in the web-browser, fs.readFile may not have been shimmed.\n        throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\n    };\nconst GOOGLE_TOKEN_URL = 'https://www.googleapis.com/oauth2/v4/token';\nconst GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';\nclass ErrorWithCode extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nlet getPem;\nclass GoogleToken {\n    /**\n     * Create a GoogleToken.\n     *\n     * @param options  Configuration object.\n     */\n    constructor(options) {\n        this.configure(options);\n    }\n    get accessToken() {\n        return this.rawToken ? this.rawToken.access_token : undefined;\n    }\n    get idToken() {\n        return this.rawToken ? this.rawToken.id_token : undefined;\n    }\n    get tokenType() {\n        return this.rawToken ? this.rawToken.token_type : undefined;\n    }\n    get refreshToken() {\n        return this.rawToken ? this.rawToken.refresh_token : undefined;\n    }\n    /**\n     * Returns whether the token has expired.\n     *\n     * @return true if the token has expired, false otherwise.\n     */\n    hasExpired() {\n        const now = new Date().getTime();\n        if (this.rawToken && this.expiresAt) {\n            return now >= this.expiresAt;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns whether the token will expire within eagerRefreshThresholdMillis\n     *\n     * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\n     */\n    isTokenExpiring() {\n        var _a;\n        const now = new Date().getTime();\n        const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;\n        if (this.rawToken && this.expiresAt) {\n            return this.expiresAt <= now + eagerRefreshThresholdMillis;\n        }\n        else {\n            return true;\n        }\n    }\n    getToken(callback, opts = {}) {\n        if (typeof callback === 'object') {\n            opts = callback;\n            callback = undefined;\n        }\n        opts = Object.assign({\n            forceRefresh: false,\n        }, opts);\n        if (callback) {\n            const cb = callback;\n            this.getTokenAsync(opts).then(t => cb(null, t), callback);\n            return;\n        }\n        return this.getTokenAsync(opts);\n    }\n    /**\n     * Given a keyFile, extract the key and client email if available\n     * @param keyFile Path to a json, pem, or p12 file that contains the key.\n     * @returns an object with privateKey and clientEmail properties\n     */\n    async getCredentials(keyFile) {\n        const ext = path.extname(keyFile);\n        switch (ext) {\n            case '.json': {\n                const key = await readFile(keyFile, 'utf8');\n                const body = JSON.parse(key);\n                const privateKey = body.private_key;\n                const clientEmail = body.client_email;\n                if (!privateKey || !clientEmail) {\n                    throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\n                }\n                return { privateKey, clientEmail };\n            }\n            case '.der':\n            case '.crt':\n            case '.pem': {\n                const privateKey = await readFile(keyFile, 'utf8');\n                return { privateKey };\n            }\n            case '.p12':\n            case '.pfx': {\n                // NOTE:  The loading of `google-p12-pem` is deferred for performance\n                // reasons.  The `node-forge` npm module in `google-p12-pem` adds a fair\n                // bit time to overall module loading, and is likely not frequently\n                // used.  In a future release, p12 support will be entirely removed.\n                if (!getPem) {\n                    getPem = (await Promise.resolve().then(() => require('google-p12-pem'))).getPem;\n                }\n                const privateKey = await getPem(keyFile);\n                return { privateKey };\n            }\n            default:\n                throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' +\n                    'Current supported extensions are *.json, *.pem, and *.p12.', 'UNKNOWN_CERTIFICATE_TYPE');\n        }\n    }\n    async getTokenAsync(opts) {\n        if (this.inFlightRequest && !opts.forceRefresh) {\n            return this.inFlightRequest;\n        }\n        try {\n            return await (this.inFlightRequest = this.getTokenAsyncInner(opts));\n        }\n        finally {\n            this.inFlightRequest = undefined;\n        }\n    }\n    async getTokenAsyncInner(opts) {\n        if (this.isTokenExpiring() === false && opts.forceRefresh === false) {\n            return Promise.resolve(this.rawToken);\n        }\n        if (!this.key && !this.keyFile) {\n            throw new Error('No key or keyFile set.');\n        }\n        if (!this.key && this.keyFile) {\n            const creds = await this.getCredentials(this.keyFile);\n            this.key = creds.privateKey;\n            this.iss = creds.clientEmail || this.iss;\n            if (!creds.clientEmail) {\n                this.ensureEmail();\n            }\n        }\n        return this.requestToken();\n    }\n    ensureEmail() {\n        if (!this.iss) {\n            throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\n        }\n    }\n    revokeToken(callback) {\n        if (callback) {\n            this.revokeTokenAsync().then(() => callback(), callback);\n            return;\n        }\n        return this.revokeTokenAsync();\n    }\n    async revokeTokenAsync() {\n        if (!this.accessToken) {\n            throw new Error('No token to revoke.');\n        }\n        const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\n        await gaxios_1.request({ url });\n        this.configure({\n            email: this.iss,\n            sub: this.sub,\n            key: this.key,\n            keyFile: this.keyFile,\n            scope: this.scope,\n            additionalClaims: this.additionalClaims,\n        });\n    }\n    /**\n     * Configure the GoogleToken for re-use.\n     * @param  {object} options Configuration object.\n     */\n    configure(options = {}) {\n        this.keyFile = options.keyFile;\n        this.key = options.key;\n        this.rawToken = undefined;\n        this.iss = options.email || options.iss;\n        this.sub = options.sub;\n        this.additionalClaims = options.additionalClaims;\n        if (typeof options.scope === 'object') {\n            this.scope = options.scope.join(' ');\n        }\n        else {\n            this.scope = options.scope;\n        }\n        this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\n    }\n    /**\n     * Request the token from Google.\n     */\n    async requestToken() {\n        const iat = Math.floor(new Date().getTime() / 1000);\n        const additionalClaims = this.additionalClaims || {};\n        const payload = Object.assign({\n            iss: this.iss,\n            scope: this.scope,\n            aud: GOOGLE_TOKEN_URL,\n            exp: iat + 3600,\n            iat,\n            sub: this.sub,\n        }, additionalClaims);\n        const signedJWT = jws.sign({\n            header: { alg: 'RS256' },\n            payload,\n            secret: this.key,\n        });\n        try {\n            const r = await gaxios_1.request({\n                method: 'POST',\n                url: GOOGLE_TOKEN_URL,\n                data: {\n                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                    assertion: signedJWT,\n                },\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n                responseType: 'json',\n            });\n            this.rawToken = r.data;\n            this.expiresAt =\n                r.data.expires_in === null || r.data.expires_in === undefined\n                    ? undefined\n                    : (iat + r.data.expires_in) * 1000;\n            return this.rawToken;\n        }\n        catch (e) {\n            this.rawToken = undefined;\n            this.tokenExpires = undefined;\n            const body = e.response && e.response.data ? e.response.data : {};\n            if (body.error) {\n                const desc = body.error_description\n                    ? `: ${body.error_description}`\n                    : '';\n                e.message = `${body.error}${desc}`;\n            }\n            throw e;\n        }\n    }\n}\nexports.GoogleToken = GoogleToken;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}